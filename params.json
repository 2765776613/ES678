{"name":"Es678","tagline":"ES6、ES7、ES8的一些新特性","body":"## ES6的一些新特性\r\n\r\n### 1. let和const\r\n\r\n  1. 之前js定义变量只有一个关键字：`var`    **(`var`存在一个问题，就是定义的变量有时会莫名奇妙的成为全局变量)**\r\n\r\n     ```js\r\n     for (var i = 0; i < 5; i++) {\r\n         console.log(i);\r\n     }\r\n     console.log(\"循环外\" + i);  // 5\r\n     ```\r\n\r\n     \t2. `let`所声明的变量，只在`let`命令所在的代码块内有效。\r\n\r\n     ```js\r\n     for (let i = 0; i < 5; i++) {\r\n         console.log(i);\r\n     }\r\n     console.log(\"循环外\" + i);   // 报错\r\n     ```\r\n\r\n     \t3. `const`声明的变量是常量，不能被修改\r\n\r\n     ```js\r\n     const a = 10;\r\n     a = 321;  // 报错\r\n     ```\r\n\r\n### 2. 字符串扩展\r\n\r\n 1. `includes()`：返回布尔值，表示是否找到了参数字符串\r\n\r\n 2. `startsWith()`：返回布尔值，表示参数字符串是否在原字符串的头部。\r\n\r\n 3. `endsWith()`：返回布尔值，表示参数字符串是否在原字符串的尾部\r\n\r\n    ```js\r\n    let str = \"hello\";\r\n    console.log(str.includes(\"ell\"));  // true\r\n    console.log(str.startsWith(\"he\")); // true\r\n    console.log(str.endsWith(\"llo\"));  // true\r\n    ```\r\n\r\n4. ES6中提供了\\`来作为字符串模板标记，在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本。\r\n\r\n### 3. 解构表达式\r\n\r\n1. 数组解构\r\n\r\n   ```js\r\n   let arr = [1, 2, 3, 4];\r\n   const [x, y, z, ] = arr;\r\n   console.log(x, y, z);  // 1 2 3\r\n   let [, ...rest] = arr;\r\n   console.log(rest);  // [2,3,4]\r\n   ```\r\n\r\n2. json对象解构\r\n\r\n   ```js\r\n   const person = {\r\n       name:\"jack\",\r\n       age:21,\r\n       language: ['java','js','css']\r\n   }\r\n   // 解构表达式获取值\r\n   const {name,age,language} = person;\r\n   // 浏览器控制台打印\r\n   console.log(name);\r\n   console.log(age);\r\n   console.log(language);\r\n   const { name: n } = person;\r\n   console.log(n);   // jack\r\n   ```\r\n\r\n### 4. 函数优化\r\n\r\n1. 函数参数可预设默认值\r\n\r\n2. 箭头函数\r\n\r\n   + 一个参数时\r\n\r\n     ```js\r\n     var print = function (obj) {\r\n         console.log(obj);\r\n     }\r\n     // 简写为：\r\n     var print = obj => console.log(obj);\r\n     ```\r\n\r\n   + 多个参数时\r\n\r\n     ```js\r\n     var sum = function (a , b) {\r\n         return a + b;\r\n     }\r\n     // 简写为：\r\n     var sum = (a,b) => a+b;\r\n     ```\r\n\r\n### 5. map和reduce方法\r\n\r\n1. ` map()`：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。\r\n\r\n   ```js\r\n   let arr = ['1', '20', '-5', '3'];\r\n   console.log(arr);  // [\"1\", \"20\", \"-5\", \"3\"]\r\n   let arr2 = arr.map(s => parseInt(s));\r\n   console.log(arr2)  // [1, 20, -5, 3]\r\n   ```\r\n\r\n2. `reduce()`：接收一个函数（必须）和一个初始值（可选），它会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数。\r\n\r\n   ```js\r\n   const arr = [1, 20, -5, 3];\r\n   // 未指定初始值\r\n   let num = arr.reduce((a, b) => a + b);\r\n   console.log(num);  // 1+20+-5+3=19\r\n   // 指定初始值\r\n   let num2 = arr.reduce((a, b) => a + b, 1);\r\n   console.log(num2);  // 1+1+20+-5+3=20\r\n   ```\r\n\r\n### 6. promise\r\n\r\n1. 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\r\n\r\n   ```js\r\n   const p = new Promise(function (resolve, reject) {\r\n       // 这里我们用定时任务模拟异步\r\n       setTimeout(() => {\r\n           const num = Math.random();\r\n           // 随机返回成功或失败\r\n           if (num < 0.5) {\r\n               resolve(\"成功！num:\" + num)  // 调用resolve，代表Promise将返回成功的结果\r\n           } else {\r\n               reject(\"出错了！num:\" + num) // 调用reject，代表Promise会返回失败的结果\r\n           }\r\n       }, 300)\r\n   })\r\n   \r\n   // 调用promise\r\n   p.then(function (msg) {\r\n       // 异步执行成功后的回调\r\n       console.log(msg);\r\n   }).catch(function (msg) {\r\n       // 异步执行失败后的回调\r\n       console.log(msg);\r\n   })\r\n   ```\r\n\r\n### 7. 模块化\r\n\r\n1. 模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。模块功能主要由两个命令构成：`export`和`import`。\r\n\r\n   - `export`命令用于规定模块的对外接口。\r\n   - `import`命令用于导入其他模块提供的功能。\r\n\r\n2. `export`：\r\n\r\n   ```js\r\n   // 导出对象\r\n   export const util = {\r\n       sum(a,b){\r\n           return a + b;\r\n       }\r\n   }\r\n   // 导出变量\r\n   var name = \"jack\"\r\n   var age = 21\r\n   export {name,age}\t\r\n   ```\r\n\r\n3. 使用`export`命令定义了模块的对外接口以后，其他 JS 文件就可以通过`import`命令加载这个模块。\r\n\r\n   ```js\r\n   // 导入util\r\n   import util from 'hello.js'\r\n   // 调用util中的属性\r\n   util.sum(1,2)\r\n   \r\n   import {name, age} from 'user.js'\r\n   console.log(name + \" , 今年\"+ age +\"岁了\")\r\n   ```\r\n\r\n### 8. 数组扩展方法\r\n\r\n1. find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素\r\n2. findIndex(callback)：与find类似，不过返回的是匹配到的元素的索引\r\n3. includes(callback)：与find类似，如果匹配到元素，则返回true，代表找到了。\r\n\r\n\r\n\r\n## ES7的新特性\r\n\r\n1. 什么是`async`、`await`？\r\n\r\n   + async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。**（await只能在async函数中使用）**\r\n\r\n   + 通常async、await都是跟随Promise一起使用的。\r\n\r\n   + await得到Promise对象之后就等待Promise接下来的resolve或者reject。\r\n\r\n   ```js\r\n   async function testSync() {\r\n        const response = await new Promise(resolve => {\r\n            setTimeout(() => {\r\n                resolve(\"async await test...\");\r\n             }, 1000);\r\n        });\r\n        console.log(response);\r\n   }\r\n   testSync();//async await test...\r\n   ```\r\n\r\n   \r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}